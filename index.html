<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>D&D Алхимия — грейды эффектов + JSON + /img</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0c10; color: #e8e8e8; }
    header { padding: 14px 18px; border-bottom: 1px solid #2b2e3a; background: #0f1117; }
    header h1 { margin: 0; font-size: 16px; }
    header .row { margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    main { display: grid; grid-template-columns: 1.2fr 0.9fr 0.9fr; gap: 12px; padding: 12px; }
    .panel { background: #111522; border: 1px solid #2b2e3a; border-radius: 12px; overflow: hidden; }
    .panel h2 { margin: 0; padding: 12px; font-size: 13px; border-bottom: 1px solid #2b2e3a; background: #0f1320; }
    .panel .body { padding: 12px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    input, select, button, textarea {
      background: #0f1320; color: #e8e8e8; border: 1px solid #2b2e3a; border-radius: 10px;
      padding: 8px 10px;
    }
    textarea { width:100%; min-height:70px; resize:vertical; }
    button { cursor: pointer; }
    button:hover { border-color: #5b63ff; }
    .list { display: grid; gap: 8px; }
    .card { border: 1px solid #2b2e3a; border-radius: 12px; padding: 10px; background: #0f1320; }
    .card .top { display: flex; justify-content: space-between; gap: 10px; }
    .tag { font-size: 12px; opacity: 0.9; border: 1px solid #2b2e3a; padding: 2px 8px; border-radius: 999px; }
    .small { font-size: 12px; opacity: 0.85; line-height: 1.3; }
    .pillbar { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 6px; }
    .pill { font-size: 12px; border: 1px solid #2b2e3a; padding: 2px 8px; border-radius: 999px; background: #0b0f1d; }
    .zone { min-height: 90px; border: 1px dashed #2b2e3a; border-radius: 12px; padding: 10px; background: rgba(255,255,255,0.02); }
    .zone.dragover { border-color: #5b63ff; }
    .item { display: inline-flex; align-items: center; gap: 6px; border: 1px solid #2b2e3a; border-radius: 999px; padding: 6px 10px; margin: 4px 6px 0 0; background: #0b0f1d; }
    .item button { padding: 2px 8px; border-radius: 999px; }
    .result { font-size: 14px; line-height: 1.35; }
    .muted { opacity: 0.8; }
    .img { width: 44px; height: 44px; object-fit: cover; border: 1px solid #2b2e3a; border-radius: 10px; background:#0b0f1d; }
    .imgBig { width: 120px; height: 120px; object-fit: cover; border: 1px solid #2b2e3a; border-radius: 14px; background:#0b0f1d; }
    .split { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .danger { border-color:#ff5b5b !important; }
    .ok { border-color:#5bff86 !important; }
    footer { padding: 12px 18px; border-top: 1px solid #2b2e3a; background: #0f1117; font-size: 12px; opacity: 0.85; }
    code { background: rgba(255,255,255,0.06); padding: 2px 6px; border-radius: 6px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
  </style>
</head>

<body>
<header>
  <h1>Алхимия • грейды для ВСЕХ эффектов • DC/время растут • JSON • картинки из <code>/img</code></h1>
  <div class="row">
    <button id="exportJson">Экспорт JSON</button>
    <label class="small">Импорт JSON:
      <input id="importJson" type="file" accept="application/json" style="padding:6px 10px; margin-left:6px;">
    </label>
    <button id="resetAll" class="danger">Сбросить всё</button>
    <span class="small muted">Картинки: укажи имя файла (<code>moss.png</code>) → путь <code>./img/moss.png</code></span>
  </div>
</header>

<main>
  <section class="panel">
    <h2>Ингредиенты</h2>
    <div class="body">
      <div class="row" style="margin-bottom:10px">
        <input id="search" placeholder="Поиск по названию/эффекту/описанию…" style="flex:1" />
        <select id="rarityFilter">
          <option value="">Редкость: любая</option>
          <option value="common">Обычный</option>
          <option value="uncommon">Необычный</option>
          <option value="rare">Редкий</option>
          <option value="very_rare">Очень редкий</option>
        </select>
        <button id="openIngredientEditor">+ Ингредиент</button>
      </div>
      <div class="small muted" style="margin-bottom:10px">
        Грейд эффекта зависит от “суммы экстракта” по этому эффекту (только от ингредиентов, где он есть).
        Drag&Drop: перетащи ингредиент в мешочек/реторту. Лимит реторты: 3.
      </div>
      <div id="ingredients" class="list"></div>
    </div>
  </section>

  <section class="panel">
    <h2>Мешочек компонентов</h2>
    <div class="body">
      <div id="bagZone" class="zone" data-zone="bag">
        <div class="small muted">Перетащи сюда ингредиенты или кликай “В мешочек”.</div>
        <div id="bagItems"></div>
      </div>
      <div class="row" style="margin-top:10px">
        <button id="bagToRetort">→ В реторту</button>
        <button id="clearBag">Очистить мешочек</button>
      </div>

      <hr style="border:0;border-top:1px solid #2b2e3a;margin:12px 0">
      <div class="row" style="margin-bottom:8px">
        <strong class="small">Рецепты</strong>
        <button id="openRecipeEditor">+ Рецепт</button>
      </div>
      <div class="small muted" style="margin-bottom:8px">
        Приоритет варки: 1) точный рецепт по ингредиентам, 2) рецепт по эффектам, 3) пересечение эффектов (Skyrim-логика).
        Грейд всё равно считается по экстракту.
      </div>
      <div id="recipes" class="list"></div>

      <hr style="border:0;border-top:1px solid #2b2e3a;margin:12px 0">
      <div class="row" style="margin-bottom:8px">
        <strong class="small">Кастомные эффекты</strong>
        <button id="openEffectEditor">+ Эффект</button>
      </div>
      <div class="small muted" style="margin-bottom:8px">
        Эффекты — тэги. У кастом-эффекта можно не задавать “грейд-описания”: тогда грейд будет влиять только на DC/время.
      </div>
      <div id="effectsList" class="list"></div>
    </div>
  </section>

  <section class="panel">
    <h2>Алхимическая реторта</h2>
    <div class="body">
      <div class="row" style="margin-bottom:10px">
        <label class="small">Лаба:</label>
        <select id="labTier">
          <option value="t0">Tier 0 (полевой набор)</option>
          <option value="t1" selected>Tier 1 (домашняя лаба)</option>
          <option value="t2">Tier 2 (лаба + Ядро)</option>
        </select>

        <label class="small">Эффектов:</label>
        <select id="maxEffects">
          <option value="1" selected>1</option>
          <option value="2">2 (если есть 2 пересечения)</option>
        </select>

        <label class="small">Дневник:</label>
        <select id="timeMode">
          <option value="rests" selected>В долгих отдыхах</option>
          <option value="days">В днях (1 отдых ≈ 1 день)</option>
        </select>
      </div>

      <div id="retortZone" class="zone" data-zone="retort">
        <div class="small muted">Перетащи ингредиенты сюда или нажми “→ В реторту”.</div>
        <div id="retortItems"></div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="brew">Сварить</button>
        <button id="clearRetort">Очистить реторту</button>
      </div>

      <div class="panel" style="margin-top:12px">
        <h2>Результат</h2>
        <div class="body result" id="result">
          <div class="muted">Добавь 2–3 ингредиента в реторту и нажми “Сварить”.</div>
        </div>
      </div>

      <div class="small muted" style="margin-top:10px">
        Грейд-формула: по каждому эффекту считаем <code>support</code> = сумма <code>extractPower</code> у ингредиентов, где есть этот эффект.
        Затем Tier: 2–3→I, 4–5→II, 6–7→III, 8+→IV.
      </div>
    </div>
  </section>
</main>

<footer>
  Данные: localStorage (твой браузер). Экспорт JSON = бэкап/перенос. Картинки лежат рядом в папке <code>/img</code>.
</footer>

<!-- Ingredient dialog -->
<dialog id="ingredientDialog" style="max-width:900px; width: min(900px, 92vw); background:#0f1117; color:#e8e8e8; border:1px solid #2b2e3a; border-radius:14px; padding:0">
  <form method="dialog" style="margin:0">
    <div style="padding:12px 14px; border-bottom:1px solid #2b2e3a; display:flex; justify-content:space-between; align-items:center;">
      <strong id="ingredientDialogTitle">Ингредиент</strong>
      <button value="cancel">Закрыть</button>
    </div>

    <div style="padding:12px 14px" class="split">
      <div>
        <div class="row" style="margin-bottom:8px">
          <input id="ing_id" placeholder="id (латиница, без пробелов)" style="flex:1" />
          <select id="ing_rarity">
            <option value="common">Обычный</option>
            <option value="uncommon">Необычный</option>
            <option value="rare">Редкий</option>
            <option value="very_rare">Очень редкий</option>
          </select>
        </div>

        <input id="ing_name" placeholder="Название" style="width:100%; margin-bottom:8px" />

        <div class="row" style="margin-bottom:8px">
          <input id="ing_cost" type="number" min="0" step="1" placeholder="Стоимость (зм)" style="width:200px" />
          <input id="ing_extract" type="number" min="1" step="1" placeholder="extractPower (опц.)" style="width:200px" />
          <input id="ing_image_file" placeholder="Картинка (например moss.png)" style="flex:1" />
        </div>

        <textarea id="ing_desc" placeholder="Описание ингредиента (лоре/заметки/применение)"></textarea>

        <div class="small muted" style="margin:10px 0 6px">Эффекты (тэги): выбери 1–6.</div>
        <div id="ing_effects" class="row" style="margin-bottom:10px"></div>

        <div class="row">
          <button id="ing_quick_add_effect" type="button">+ Быстро добавить новый эффект</button>
          <span class="small muted">Создаст кастом-эффект и отметит его.</span>
        </div>
      </div>

      <div>
        <div class="small muted" style="margin-bottom:6px">Превью</div>
        <img id="ing_preview" class="imgBig" alt="preview" style="display:none" />
        <div class="small muted" style="margin-top:10px">
          extractPower по умолчанию = по редкости (common=1, uncommon=2, rare=3, very_rare=4). Можно переопределить вручную.
        </div>
      </div>
    </div>

    <div style="padding:12px 14px; border-top:1px solid #2b2e3a; display:flex; gap:8px; justify-content:flex-end;">
      <button id="ing_delete" type="button" class="danger">Удалить</button>
      <button id="ing_save" type="button" class="ok">Сохранить</button>
    </div>
  </form>
</dialog>

<!-- Recipe dialog -->
<dialog id="recipeDialog" style="max-width:920px; width: min(920px, 92vw); background:#0f1117; color:#e8e8e8; border:1px solid #2b2e3a; border-radius:14px; padding:0">
  <form method="dialog" style="margin:0">
    <div style="padding:12px 14px; border-bottom:1px solid #2b2e3a; display:flex; justify-content:space-between; align-items:center;">
      <strong id="recipeDialogTitle">Рецепт</strong>
      <button value="cancel">Закрыть</button>
    </div>

    <div style="padding:12px 14px" class="split">
      <div>
        <div class="row" style="margin-bottom:8px">
          <input id="rec_id" placeholder="id рецепта" style="flex:1" />
          <select id="rec_kind">
            <option value="ingredients" selected>По ингредиентам (точный список)</option>
            <option value="effects">По эффектам (тэги должны быть среди ингредиентов)</option>
          </select>
        </div>

        <input id="rec_name" placeholder="Название результата (зелья/яда)" style="width:100%; margin-bottom:8px" />
        <textarea id="rec_desc" placeholder="Описание эффекта (текст для результата). Можно писать “Tier I/II/III/IV”, если хочешь ручные градации."></textarea>

        <div class="row" style="margin-top:8px">
          <label class="small">Сила (влияет на DC):</label>
          <select id="rec_power">
            <option value="0">Малая (+0)</option>
            <option value="1" selected>Средняя (+2)</option>
            <option value="2">Сильная (+4)</option>
          </select>
          <label class="small">Базовый DC (опц.):</label>
          <input id="rec_base_dc" type="number" min="0" placeholder="пусто = авто" style="width:140px" />
        </div>

        <div class="row" style="margin-top:8px">
          <input id="rec_image_file" placeholder="Картинка результата (например potion_heal.png)" style="flex:1" />
        </div>
        <div class="row" style="margin-top:8px">
          <input id="rec_img_t1" placeholder="Картинка Tier I (например small_potion_heal.png)" style="flex:1" />
        </div>
        <div class="row" style="margin-top:8px">
          <input id="rec_img_t2" placeholder="Картинка Tier II (например potion_heal.png)" style="flex:1" />
        </div>
        <div class="row" style="margin-top:8px">
          <input id="rec_img_t3" placeholder="Картинка Tier III (например big_potion_heal.png)" style="flex:1" />
        </div>
        <div class="row" style="margin-top:8px">
          <input id="rec_img_t4" placeholder="Картинка Tier IV (например epic_potion_heal.png)" style="flex:1" />
        </div>


        <hr style="border:0;border-top:1px solid #2b2e3a;margin:12px 0">
        <div class="small muted" style="margin-bottom:6px">Условия рецепта:</div>
        <div id="rec_match_area"></div>
      </div>

      <div>
        <div class="small muted" style="margin-bottom:6px">Превью результата</div>
        <img id="rec_preview" class="imgBig" alt="preview" style="display:none" />
        <div class="small muted" style="margin-top:10px">
          Грейд рецепта всё равно будет считаться по экстракту. Рецепт определяет “что именно получилось”, а не насколько мощно.
        </div>
      </div>
    </div>

    <div style="padding:12px 14px; border-top:1px solid #2b2e3a; display:flex; gap:8px; justify-content:flex-end;">
      <button id="rec_delete" type="button" class="danger">Удалить</button>
      <button id="rec_save" type="button" class="ok">Сохранить</button>
    </div>
  </form>
</dialog>

<!-- Effect dialog -->
<dialog id="effectDialog" style="max-width:760px; width: min(760px, 92vw); background:#0f1117; color:#e8e8e8; border:1px solid #2b2e3a; border-radius:14px; padding:0">
  <form method="dialog" style="margin:0">
    <div style="padding:12px 14px; border-bottom:1px solid #2b2e3a; display:flex; justify-content:space-between; align-items:center;">
      <strong id="effectDialogTitle">Эффект</strong>
      <button value="cancel">Закрыть</button>
    </div>

    <div style="padding:12px 14px">
      <div class="row" style="margin-bottom:8px">
        <input id="eff_id" placeholder="id эффекта (например reflect_melee_half)" style="flex:1" />
        <select id="eff_power">
          <option value="1">Сила 1</option>
          <option value="2">Сила 2</option>
          <option value="3">Сила 3</option>
        </select>
      </div>
      <input id="eff_name" placeholder="Название эффекта" style="width:100%; margin-bottom:8px" />
      <textarea id="eff_desc" placeholder="Описание эффекта (база). Грейды для кастом-эффектов можно описывать вручную в рецепте/лоре."></textarea>

      <div class="small muted" style="margin-top:10px">Грейды (Tier I–IV) — опционально</div>
      <textarea id="eff_t1" placeholder="Tier I описание"></textarea>
      <textarea id="eff_t2" placeholder="Tier II описание"></textarea>
      <textarea id="eff_t3" placeholder="Tier III описание"></textarea>
      <textarea id="eff_t4" placeholder="Tier IV описание"></textarea>

      <div class="row" style="margin-top:8px">
        <input id="eff_image_file" placeholder="Картинка эффекта (например poison.png)" style="flex:1" />
      </div>
      <div class="row" style="margin-top:8px">
        <input id="eff_img_t1" placeholder="Картинка Tier I" style="flex:1" />
      </div>
      <div class="row" style="margin-top:8px">
        <input id="eff_img_t2" placeholder="Картинка Tier II" style="flex:1" />
      </div>
      <div class="row" style="margin-top:8px">
        <input id="eff_img_t3" placeholder="Картинка Tier III" style="flex:1" />
      </div>
      <div class="row" style="margin-top:8px">
        <input id="eff_img_t4" placeholder="Картинка Tier IV" style="flex:1" />
      </div>
      <div class="small muted">Удаляются только кастомные эффекты (базовые — “вшиты”).</div>
    </div>

    <div style="padding:12px 14px; border-top:1px solid #2b2e3a; display:flex; gap:8px; justify-content:flex-end;">
      <button id="eff_delete" type="button" class="danger">Удалить</button>
      <button id="eff_save" type="button" class="ok">Сохранить</button>
    </div>
  </form>
</dialog>

<script>
/* ========= Config ========= */
const IMG_BASE = "./img/";
const STORE_KEY = "alchemy_v5_store";

/* ========= Rarity & extract defaults ========= */
const RARITY = {
  common:    { name: "Обычный",      dc: 0, extract: 1 },
  uncommon:  { name: "Необычный",    dc: 1, extract: 2 },
  rare:      { name: "Редкий",       dc: 2, extract: 3 },
  very_rare: { name: "Очень редкий", dc: 3, extract: 4 }
};

/* ========= Tier thresholds (support -> tier) ========= */
function tierFromSupport(support){
  // support is sum of extractPower for ingredients that contain the effect
  if (support >= 8) return 4;
  if (support >= 6) return 3;
  if (support >= 4) return 2;
  return 1; // 2–3 normally ends here
}
function tierRoman(t){ return ["I","II","III","IV"][clampInt(t,1,4)-1]; }

/* ========= Base effects with tiered descriptions =========
   For custom effects without tiers: tier affects only DC/time.
*/
const BASE_EFFECTS = {
  heal_minor: {
    name: "Лечение",
    power: 1,
    tiers: [
      { desc: "Восстанови 2d4+2 HP." },
      { desc: "Восстанови 4d4+4 HP." },
      { desc: "Восстанови 8d4+8 HP." },
      { desc: "Восстанови 10d4+20 HP." }
    ]
  },
  
  resist_acid: {
    name: "Сопротивление кислоте",
    power: 1,
    tiers: [
      { desc: "Сопротивление кислоте на 10 минут." },
      { desc: "Сопротивление кислоте на 1 час." },
      { desc: "Сопротивление кислоте на 8 часов." },
      { desc: "Сопротивление кислоте на 24 часа." }
    ]
  },
  resist_cold: {
    name: "Сопротивление холоду",
    power: 1,
    tiers: [
      { desc: "Сопротивление холоду на 10 минут." },
      { desc: "Сопротивление холоду на 1 час." },
      { desc: "Сопротивление холоду на 8 часов." },
      { desc: "Сопротивление холоду на 24 часа." }
    ]
  },
  resist_fire: {
    name: "Сопротивление огню",
    power: 1,
    tiers: [
      { desc: "Сопротивление огню на 10 минут." },
      { desc: "Сопротивление огню на 1 час." },
      { desc: "Сопротивление огню на 8 часов." },
      { desc: "Сопротивление огню на 24 часа." }
    ]
  },
  antitoxin: {
    name: "Антитоксин",
    power: 1,
    tiers: [
      { desc: "Преимущество на спасброски от яда на 1 час." },
      { desc: "Преимущество на спасброски от яда на 8 часов." },
      { desc: "Преимущество на спасброски от яда на 24 часа." },
      { desc: "Преимущество на спасброски от яда на 7 дней." }
    ]
  },
  poison_basic: {
    name: "Яд (оружейный)",
    power: 1,
    tiers: [
      { desc: "При попадании: КС 12 Телосложения, 2d6 урона ядом (половина при успехе)." },
      { desc: "При попадании: КС 13 Телосложения, 4d6 урона ядом (половина при успехе)." },
      { desc: "При попадании: КС 15 Телосложения, 6d6 урона ядом (половина при успехе)." },
      { desc: "При попадании: КС 17 Телосложения, 8d6 урона ядом (половина при успехе) и состояние Poisoned до конца следующего хода." }
    ]
  },
  slow: {
    name: "Замедление",
    power: 1,
    tiers: [
      { desc: "КС 12 Тел: скорость −10 фт на 1 минуту (повтор в конце хода)." },
      { desc: "КС 13 Тел: скорость −10 фт и −1d4 к инициативе на 1 минуту (повтор в конце хода)." },
      { desc: "КС 15 Тел: скорость −20 фт на 10 минут (повтор раз в минуту)." },
      { desc: "КС 17 Тел: скорость −20 фт и без реакций на 10 минут (повтор раз в минуту)." }
    ]
  },
  sleepiness: {
    name: "Сонливость",
    power: 1,
    tiers: [
      { desc: "КС 12 Тел: не может делать реакции 1 минуту (повтор в конце хода)." },
      { desc: "КС 13 Тел: состояние Dazed (на выбор мастера) / без реакций 1 минуту (повтор в конце хода)." },
      { desc: "КС 15 Тел: при провале ещё и Prone, длительность 10 минут (повтор раз в минуту)." },
      { desc: "КС 17 Тел: при провале Unconscious на 1 раунд, затем сонливость 10 минут (повтор раз в минуту)." }
    ]
  },
  darkvision: {
    name: "Тёмное зрение",
    power: 1,
    tiers: [
      { desc: "Тёмное зрение 60 фт на 1 час (если нет)." },
      { desc: "Тёмное зрение 60 фт на 8 часов (если нет)." },
      { desc: "Тёмное зрение 60 фт на 24 часа (если нет)." },
      { desc: "Тёмное зрение 120 фт на 24 часа (если нет)." }
    ]
  },
  waterbreath: {
    name: "Дыхание под водой",
    power: 2,
    tiers: [
      { desc: "Дышать под водой 1 час." },
      { desc: "Дышать под водой 8 часов." },
      { desc: "Дышать под водой 24 часа." },
      { desc: "Дышать под водой 7 дней." }
    ]
  },
  speed: {
    name: "Проворство",
    power: 1,
    tiers: [
      { desc: "Скорость +10 фт на 10 минут." },
      { desc: "Скорость +10 фт на 1 час." },
      { desc: "Скорость +20 фт на 1 час." },
      { desc: "Скорость +20 фт на 8 часов." }
    ]
  },
  clarity: {
    name: "Ясность",
    power: 1,
    tiers: [
      { desc: "Преимущество на Внимательность/Расследование 1 час." },
      { desc: "Преимущество на Внимательность/Расследование 8 часов." },
      { desc: "Преимущество на Внимательность/Расследование 24 часа." },
      { desc: "Преимущество на Внимательность/Расследование 7 дней." }
    ]
  },
  jump: {
    name: "Прыжок",
    power: 1,
    tiers: [
      { desc: "Эффект заклинания Jump на 1 минут (концентрация не требуется)." },
      { desc: "Jump на 10 минут (без концентрации)." },
      { desc: "Jump на 1 час (без концентрации)." },
      { desc: "Jump на 8 часов (без концентрации)." }
    ]
  },

  flight: {
    name: "Полёт",
    power: 3,
    tiers: [
      { desc: "Полёт (скорость полёта 30 фт) на 1 минуту (без концентрации)." },
      { desc: "Полёт (30 фт) на 10 минут (без концентрации)." },
      { desc: "Полёт (40 фт) на 1 час (без концентрации)." },
      { desc: "Полёт (60 фт) на 1 час (без концентрации). На усмотрение мастера: побочка после окончания (усталость/истощение 1)." }
    ]
  },

  water_walk: {
    name: "Хождение по воде",
    power: 2,
    tiers: [
      { desc: "Эффект Water Walk на 10 минут (без концентрации)." },
      { desc: "Water Walk на 1 час (без концентрации)." },
      { desc: "Water Walk на 8 часов (без концентрации)." },
      { desc: "Water Walk на 24 часа (без концентрации)." }
    ]
  },

  ac_boost: {
    name: "Повышение КД",
    power: 2,
    tiers: [
      { desc: "+1 к КД на 10 минут." },
      { desc: "+1 к КД на 1 час." },
      { desc: "+2 к КД на 1 час." },
      { desc: "+2 к КД на 8 часов." }
    ]
  },

  levitation: {
    name: "Левитация",
    power: 2,
    tiers: [
      { desc: "Эффект Levitate на 1 минуту (без концентрации)." },
      { desc: "Levitate на 10 минут (без концентрации)." },
      { desc: "Levitate на 1 час (без концентрации)." },
      { desc: "Levitate на 8 часов (без концентрации)." }
    ]
  },

  dispel_magic: {
    name: "Рассеивание магии",
    power: 3,
    tiers: [
      { desc: "1 раз: Dispel Magic как ячейка 3 круга (проверки как обычно)." },
      { desc: "1 раз: Dispel Magic как ячейка 4 круга." },
      { desc: "1 раз: Dispel Magic как ячейка 5 круга." },
      { desc: "1 раз: Dispel Magic как ячейка 6 круга (очень редкий/опасный эффект)." }
    ]
  },

  paralysis: {
    name: "Паралич",
    power: 3,
    tiers: [
      { desc: "При попадании/приёме: КС 12 Тел, Paralyzed до конца следующего хода." },
      { desc: "КС 13 Тел, Paralyzed на 1 минуту (повтор в конце каждого хода)." },
      { desc: "КС 15 Тел, Paralyzed на 1 минуту (повтор), при успехе — скорость 0 до конца хода." },
      { desc: "КС 17 Тел, Paralyzed на 1 минуту (повтор), при провале на 5+ — ещё и Prone." }
    ]
  },

  fire_damage: {
    name: "Урон огнём",
    power: 2,
    tiers: [
      { desc: "При попадании/выпивании: КС 12 Лов/Тел (на усмотрение), 2d6 огнём (половина при успехе)." },
      { desc: "КС 13, 4d6 огнём (половина при успехе)." },
      { desc: "КС 15, 6d6 огнём (половина при успехе)." },
      { desc: "КС 17, 8d6 огнём (половина при успехе) и цель горит: 1d6 огнём в начале своего хода (КС 15 Лов чтобы потушить)." }
    ]
  },

  lightning_damage: {
    name: "Урон электричеством",
    power: 2,
    tiers: [
      { desc: "КС 12 Лов, 2d6 молнией (половина при успехе)." },
      { desc: "КС 13, 4d6 молнией (половина при успехе)." },
      { desc: "КС 15, 6d6 молнией (половина при успехе)." },
      { desc: "КС 17, 8d6 молнией (половина при успехе) и цель не может использовать реакции до конца следующего хода." }
    ]
  },

  acid_damage: {
    name: "Урон кислотой",
    power: 2,
    tiers: [
      { desc: "КС 12 Лов, 2d6 кислотой (половина при успехе)." },
      { desc: "КС 13, 4d6 кислотой (половина при успехе)." },
      { desc: "КС 15, 6d6 кислотой (половина при успехе) и −1 к КД от не-магической брони на 1 минуту (по желанию мастера)." },
      { desc: "КС 17, 8d6 кислотой (половина при успехе) и −1 к КД/прочности не-магического доспеха (стак не более −2, по желанию мастера)." }
    ]
  },

  light: {
    name: "Свет",
    power: 1,
    tiers: [
      { desc: "Свет как заклинание Light на 1 час." },
      { desc: "Свет на 8 часов." },
      { desc: "Свет на 24 часа." },
      { desc: "Свет на 24 часа, радиус яркого/тусклого света увеличен вдвое (по желанию мастера)." }
    ]
  },

  unlock_locks: {
    name: "Отпирание замков",
    power: 2,
    tiers: [
      { desc: "1 раз: открыть простой замок/засов (DC замка до 12) без проверки." },
      { desc: "1 раз: как Knock (без громкого звука — по желанию мастера) или DC до 15." },
      { desc: "1 раз: DC до 18 или Knock + на 1 минуту преимущество на вскрытие." },
      { desc: "1 раз: DC до 20 или Knock, игнорируя обычные механические ловушки 1 уровня сложности (по желанию мастера)." }
    ]
  },

  see_invisible: {
    name: "Видение невидимого",
    power: 2,
    tiers: [
      { desc: "Эффект See Invisibility на 1 минут." },
      { desc: "See Invisibility на 10 минут." },
      { desc: "See Invisibility на 1 час." },
      { desc: "See Invisibility на 8 часов." }
    ]
  },

  true_sight: {
    name: "Истинное зрение",
    power: 3,
    tiers: [
      { desc: "Истинное зрение 30 фт на 1 минуту." },
      { desc: "Истинное зрение 30 фт на 10 минут." },
      { desc: "Истинное зрение 60 фт на 10 минут." },
      { desc: "Истинное зрение 60 фт на 1 час (очень редкий эффект)." }
    ]
  },

  ability_boost: {
    name: "Повышение характеристики",
    power: 3,
    tiers: [
      { desc: "+2 к выбранной характеристике на 10 минут (не выше 20)." },
      { desc: "+2 на 1 час (не выше 20)." },
      { desc: "+4 на 1 час (не выше 22, по желанию мастера)." },
      { desc: "+4 на 8 часов (не выше 22) и +1d4 к проверкам этой характеристики (по желанию мастера)." }
    ]
  },

  ability_damage: {
    name: "Повреждение характеристики",
    power: 3,
    tiers: [
      { desc: "КС 12 Тел/Мдр (по природе яда): −1d4 к выбранной характеристике на 10 минут (минимум 1)." },
      { desc: "КС 13: −1d4 на 1 час." },
      { desc: "КС 15: −1d6 на 1 час." },
      { desc: "КС 17: −1d6 на 8 часов; при провале на 5+ ещё и Disadvantage на проверки этой характеристики." }
    ]
  },

};

function EFFECTS_ALL(){
  return { ...BASE_EFFECTS, ...(state.store.effects || {}) };
}
function effectByKey(key){
  const all = EFFECTS_ALL();
  return all[key] || null;
}

/* ========= Defaults ========= */
const DEFAULT_CUSTOM_EFFECTS = {
  reflect_melee_half: {
    name: "Брит: отражение удара",
    power: 2,
    desc: "Отражает часть урона в ближнем бою атакующему (грейд повышает риск/сложность/время; конкретика — в рецепте/лоре)."
  ,
    imageFile: null,
    imageByTier: null
  }
};

const DEFAULT_INGREDIENTS = [
  { id:"moss", name:"Кислая моховина", rarity:"common", effects:["resist_acid","antitoxin","poison_basic","slow"], desc:"Ковёр мха с резким кислым запахом. Хорош для нейтрализации токсинов и разъедающих настоев.", cost:5, imageFile:"moss.png", extractPower: 1 },
  { id:"saltwort", name:"Солянка болотная", rarity:"common", effects:["antitoxin","heal_minor","clarity","sleepiness"], desc:"Солёная трава, которую сушат на нитях. Часто входит в домашние микстуры.", cost:3, imageFile:"saltwort.png", extractPower: 1 },
  { id:"emberleaf", name:"Угольный лист", rarity:"uncommon", effects:["resist_fire","speed","clarity","poison_basic"], desc:"Лист с прожилками как тлеющие угли. Стабилизирует горячие экстракты.", cost:15, imageFile:"emberleaf.png", extractPower: 2 },
  { id:"frostcap", name:"Морозный гриб", rarity:"uncommon", effects:["resist_cold","darkvision","sleepiness","slow"], desc:"Хрупкий гриб, который “потеет” инеем.", cost:12, imageFile:"frostcap.png", extractPower: 2 },
  { id:"mirror_salt", name:"Зеркальная соль", rarity:"rare", effects:["reflect_melee_half","resist_acid"], desc:"Соль, оставляющая на металле тонкую зеркальную плёнку. Используется в “отражающих” зельях.", cost:120, imageFile:"mirror_salt.png", extractPower: 3 }
];

const DEFAULT_RECIPES = [
  {
    id:"heal_any",
    kind:"effects",
    name:"Зелье лечения (грейдируемое)",
    desc:"Эффект зависит от Tier (I–IV) и считается по экстракту “Лечение”.",
    power:1,
    baseDc:null,
    matchIngredients:null,
    matchEffects:["heal_minor"],
    imageFile:"potion_heal.png",
    imageByTier:{"1":"small_potion_heal.png","2":"potion_heal.png","3":"big_potion_heal.png","4":"epic_potion_heal.png"}
  },
  
  {
    id:"brit_reflect",
    kind:"effects",
    name:"Зелье Брит (отражение удара)",
    desc:"Tier влияет на силу/опасность. Пример шкалы:\n• Tier I: 1/4 урона (max 10)\n• Tier II: 1/2 урона (max 20)\n• Tier III: 1/2 урона (1/ход)\n• Tier IV: 1/2 урона + КС страха/боли (на усмотрение мастера)",
    power:2,
    baseDc:null,
    matchIngredients:null,
    matchEffects:["reflect_melee_half"],
    imageFile:"potion_brit.png",
    imageByTier:null
  }
  
];

/* ========= State ========= */
const state = {
  store: null,
  bag: loadLocal("bag", []),
  retort: loadLocal("retort", []),
  editingIngredientId: null,
  editingRecipeId: null
};

function normalizeIngredient(ing){
  const r = RARITY[ing.rarity] || RARITY.common;
  const ep = (ing.extractPower === null || ing.extractPower === undefined || ing.extractPower === "") ? r.extract : Number(ing.extractPower);
  return { ...ing, extractPower: clampInt(ep, 1, 10) };
}

function loadStore(){
  try {
    const raw = localStorage.getItem(STORE_KEY);
    if (!raw) throw new Error("no store");
    const parsed = JSON.parse(raw);
    if (!parsed.ingredients || !parsed.recipes) throw new Error("bad store");
    if (!parsed.effects) parsed.effects = structuredClone(DEFAULT_CUSTOM_EFFECTS);

    parsed.ingredients = (parsed.ingredients || []).map(normalizeIngredient);
    return parsed;
  } catch {
    return {
      ingredients: structuredClone(DEFAULT_INGREDIENTS).map(normalizeIngredient),
      recipes: structuredClone(DEFAULT_RECIPES),
      effects: structuredClone(DEFAULT_CUSTOM_EFFECTS)
    };
  }
}

function saveStore(){ localStorage.setItem(STORE_KEY, JSON.stringify(state.store)); }
function loadLocal(k, fallback){
  try { return JSON.parse(localStorage.getItem("alchemy_"+k)) ?? fallback; } catch { return fallback; }
}
function saveLocal(k, v){ localStorage.setItem("alchemy_"+k, JSON.stringify(v)); }

/* ========= DOM ========= */
const elIngredients = document.getElementById("ingredients");
const elRecipes = document.getElementById("recipes");
const effectsList = document.getElementById("effectsList");
const elBagItems = document.getElementById("bagItems");
const elRetortItems = document.getElementById("retortItems");
const elSearch = document.getElementById("search");
const elRarityFilter = document.getElementById("rarityFilter");
const elResult = document.getElementById("result");

initStore();

/*========= Initialization & Store loading ========= */
async function initStore(){
  // 1. Если есть localStorage — используем его
  const raw = localStorage.getItem(STORE_KEY);
  if (raw) {
    try {
      state.store = JSON.parse(raw);
      renderAll();
      return;
    } catch(e) {
      console.warn("Ошибка чтения localStorage, пробуем JSON файл");
    }
  }

  // 2. Пытаемся загрузить alchemy_data.json
  try {
    const response = await fetch("./alchemy_data.json", { cache: "no-store" });
    if (!response.ok) throw new Error("no json file");

    const data = await response.json();

    state.store = {
      ingredients: (data.store?.ingredients || data.ingredients || []).map(normalizeIngredient),
      recipes: data.store?.recipes || data.recipes || [],
      effects: data.store?.effects || data.effects || {}
    };

    saveStore();
    renderAll();
    console.log("Загружены данные из alchemy_data.json");
    return;
  } catch (e) {
    console.warn("alchemy_data.json не найден, используются DEFAULT");
  }

  // 3. Фоллбек — DEFAULT
  state.store = {
    ingredients: structuredClone(DEFAULT_INGREDIENTS).map(normalizeIngredient),
    recipes: structuredClone(DEFAULT_RECIPES),
    effects: structuredClone(DEFAULT_CUSTOM_EFFECTS)
  };

  saveStore();
  renderAll();
}


/* ========= Top buttons ========= */
document.getElementById("resetAll").onclick = () => {
  if (!confirm("Точно сбросить всё?")) return;
  state.store = {
    ingredients: structuredClone(DEFAULT_INGREDIENTS).map(normalizeIngredient),
    recipes: structuredClone(DEFAULT_RECIPES),
    effects: structuredClone(DEFAULT_CUSTOM_EFFECTS)
  };
  state.bag = [];
  state.retort = [];
  saveStore();
  saveLocal("bag", state.bag);
  saveLocal("retort", state.retort);
  renderAll();
  showResult(null);
};

document.getElementById("exportJson").onclick = () => {
  const payload = {
    version: 5,
    exportedAt: new Date().toISOString(),
    store: state.store
  };
  downloadBlob(JSON.stringify(payload, null, 2), "alchemy_data.json", "application/json");
};

document.getElementById("importJson").onchange = async (ev) => {
  const file = ev.target.files?.[0];
  if (!file) return;
  try {
    const text = await file.text();
    const payload = JSON.parse(text);
    const imported = payload.store ?? payload;
    if (!imported.ingredients || !imported.recipes) throw new Error("В JSON нет ingredients/recipes");
    state.store = {
      ingredients: Array.isArray(imported.ingredients) ? imported.ingredients.map(normalizeIngredient) : [],
      recipes: Array.isArray(imported.recipes) ? imported.recipes : [],
      effects: imported.effects && typeof imported.effects === "object" ? imported.effects : {}
    };
    saveStore();
    renderAll();
    alert("Импорт выполнен.");
  } catch (e) {
    alert("Ошибка импорта: " + (e?.message ?? e));
  } finally {
    ev.target.value = "";
  }
};

/* ========= Bag / Retort ========= */
document.getElementById("clearBag").onclick = () => { state.bag=[]; saveLocal("bag", state.bag); renderAll(); };
document.getElementById("clearRetort").onclick = () => { state.retort=[]; saveLocal("retort", state.retort); renderAll(); showResult(null); };

document.getElementById("bagToRetort").onclick = () => {
  const canTake = Math.max(0, 3 - state.retort.length);
  const moved = [];
  while (moved.length < canTake && state.bag.length) {
    const id = state.bag.shift();
    if (state.retort.includes(id)) continue;
    moved.push(id);
  }
  state.retort.push(...moved);
  saveLocal("bag", state.bag);
  saveLocal("retort", state.retort);
  renderAll();
};

document.getElementById("brew").onclick = () => {
  const labTier = document.getElementById("labTier").value;
  const maxEffects = Number(document.getElementById("maxEffects").value);
  const timeMode = document.getElementById("timeMode").value;

  const selected = state.retort
    .map(id => state.store.ingredients.find(x => x.id === id))
    .filter(Boolean)
    .map(normalizeIngredient);

  if (selected.length < 2) return showResult({ error:"Нужно минимум 2 ингредиента в реторте." });
  if (selected.length > 3) return showResult({ error:"Для одной варки используй 2–3 ингредиента." });

  const brew = computeBrew(selected, { labTier, maxEffects, timeMode });
  showResult(brew);
};

/* ========= Search ========= */
elSearch.oninput = renderIngredients;
elRarityFilter.onchange = renderIngredients;

/* ========= Ingredient editor ========= */
const ingredientDialog = document.getElementById("ingredientDialog");
document.getElementById("openIngredientEditor").onclick = () => openIngredientEditor(null);

const ing_id = document.getElementById("ing_id");
const ing_name = document.getElementById("ing_name");
const ing_rarity = document.getElementById("ing_rarity");
const ing_cost = document.getElementById("ing_cost");
const ing_extract = document.getElementById("ing_extract");
const ing_image_file = document.getElementById("ing_image_file");
const ing_desc = document.getElementById("ing_desc");
const ing_effects = document.getElementById("ing_effects");
const ing_preview = document.getElementById("ing_preview");
const ing_save = document.getElementById("ing_save");
const ing_delete = document.getElementById("ing_delete");
const ingredientDialogTitle = document.getElementById("ingredientDialogTitle");
const ing_quick_add_effect = document.getElementById("ing_quick_add_effect");

function openIngredientEditor(id){
  state.editingIngredientId = id;
  const existing = id ? state.store.ingredients.find(i => i.id === id) : null;

  ingredientDialogTitle.textContent = existing ? `Ингредиент: ${existing.name}` : "Новый ингредиент";
  ing_id.value = existing?.id ?? "";
  ing_id.disabled = !!existing;
  ing_name.value = existing?.name ?? "";
  ing_rarity.value = existing?.rarity ?? "common";
  ing_cost.value = (existing?.cost ?? "") === 0 ? "0" : (existing?.cost ?? "");
  ing_extract.value = (existing?.extractPower ?? "") === 0 ? "" : (existing?.extractPower ?? "");
  ing_image_file.value = existing?.imageFile ?? "";
  ing_desc.value = existing?.desc ?? "";

  updatePreview(ing_preview, ing_image_file.value);
  renderIngredientEffectsCheckboxes(existing?.effects ?? []);
  ing_delete.style.display = existing ? "inline-block" : "none";
  ingredientDialog.showModal();
}

function renderIngredientEffectsCheckboxes(selectedEffects){
  ing_effects.innerHTML = "";
  const selected = new Set(selectedEffects);
  const all = EFFECTS_ALL();
  const keys = Object.keys(all).sort((a,b) => (all[a].name||a).localeCompare(all[b].name||b, "ru"));

  for (const key of keys) {
    const wrap = document.createElement("label");
    wrap.className = "pill";
    wrap.style.cursor = "pointer";
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = selected.has(key);
    cb.dataset.key = key;
    cb.style.marginRight = "6px";
    wrap.prepend(cb);
    wrap.append(document.createTextNode(all[key].name || key));
    ing_effects.appendChild(wrap);
  }
}

ing_image_file.oninput = () => updatePreview(ing_preview, ing_image_file.value);

ing_quick_add_effect.onclick = () => {
  const id = prompt("id эффекта (латиница/цифры/_/-), например reflect_melee_half:");
  if (!id) return;
  if (!/^[a-z0-9_\-]+$/i.test(id)) return alert("Неверный id.");
  if (BASE_EFFECTS[id]) return alert("Этот id занят базовым эффектом.");
  if ((state.store.effects || {})[id]) return alert("Такой кастомный эффект уже существует.");

  const name = prompt("Название эффекта:");
  if (!name) return;
  const desc = prompt("Короткое описание эффекта (правила):");
  if (!desc) return;
  const powerRaw = prompt("Сила эффекта (1/2/3). Обычно 1–2:", "2");
  const power = clampInt(Number(powerRaw || 2), 1, 3);

  state.store.effects ||= {};
  state.store.effects[id] = { name, power, desc };
  saveStore();

  const nowSelected = [...ing_effects.querySelectorAll("input[type=checkbox]")]
    .filter(cb => cb.checked).map(cb => cb.dataset.key);
  nowSelected.push(id);
  renderIngredientEffectsCheckboxes(nowSelected);

  renderEffects();
  renderIngredients();
};

ing_save.onclick = () => {
  const id = ing_id.value.trim();
  const name = ing_name.value.trim();
  if (!id || !/^[a-z0-9_\-]+$/i.test(id)) return alert("id обязателен (латиница/цифры/_/- без пробелов).");
  if (!name) return alert("Название обязательно.");

  const effects = [...ing_effects.querySelectorAll("input[type=checkbox]")]
    .filter(cb => cb.checked)
    .map(cb => cb.dataset.key);

  if (effects.length === 0) return alert("Нужно выбрать хотя бы 1 эффект.");
  if (effects.length > 6) return alert("Слишком много эффектов. Держи 1–6 (обычно 4).");

  const costRaw = ing_cost.value.trim();
  const cost = costRaw === "" ? null : Number(costRaw);
  if (cost !== null && (!Number.isFinite(cost) || cost < 0)) return alert("Стоимость должна быть числом >= 0 или пустой.");

  const extractRaw = ing_extract.value.trim();
  const r = RARITY[ing_rarity.value] || RARITY.common;
  const extractPower = extractRaw === "" ? r.extract : Number(extractRaw);
  if (!Number.isFinite(extractPower) || extractPower < 1) return alert("extractPower должен быть числом >= 1 или пустым.");

  const imageFile = ing_image_file.value.trim() || null;

  const obj = normalizeIngredient({
    id,
    name,
    rarity: ing_rarity.value,
    effects,
    desc: ing_desc.value.trim(),
    cost,
    extractPower,
    imageFile
  });

  const exists = state.store.ingredients.some(x => x.id === id);
  state.store.ingredients = exists
    ? state.store.ingredients.map(x => x.id === id ? obj : x)
    : [...state.store.ingredients, obj];

  saveStore();
  renderAll();
  ingredientDialog.close();
};

ing_delete.onclick = () => {
  const id = state.editingIngredientId;
  if (!id) return;
  if (!confirm("Удалить ингредиент?")) return;

  state.store.ingredients = state.store.ingredients.filter(i => i.id !== id);

  state.bag = state.bag.filter(x => x !== id);
  state.retort = state.retort.filter(x => x !== id);
  saveLocal("bag", state.bag);
  saveLocal("retort", state.retort);

  state.store.recipes = state.store.recipes.map(r => {
    if (r.kind === "ingredients" && Array.isArray(r.matchIngredients)) {
      return { ...r, matchIngredients: r.matchIngredients.filter(x => x !== id) };
    }
    return r;
  });

  saveStore();
  renderAll();
  ingredientDialog.close();
};

/* ========= Recipe editor ========= */
const recipeDialog = document.getElementById("recipeDialog");
document.getElementById("openRecipeEditor").onclick = () => openRecipeEditor(null);

const rec_id = document.getElementById("rec_id");
const rec_kind = document.getElementById("rec_kind");
const rec_name = document.getElementById("rec_name");
const rec_desc = document.getElementById("rec_desc");
const rec_power = document.getElementById("rec_power");
const rec_base_dc = document.getElementById("rec_base_dc");
const rec_image_file = document.getElementById("rec_image_file");
const rec_img_t1 = document.getElementById("rec_img_t1");
const rec_img_t2 = document.getElementById("rec_img_t2");
const rec_img_t3 = document.getElementById("rec_img_t3");
const rec_img_t4 = document.getElementById("rec_img_t4");
const rec_match_area = document.getElementById("rec_match_area");
const rec_preview = document.getElementById("rec_preview");
const rec_save = document.getElementById("rec_save");
const rec_delete = document.getElementById("rec_delete");
const recipeDialogTitle = document.getElementById("recipeDialogTitle");

function openRecipeEditor(id){
  state.editingRecipeId = id;
  const existing = id ? state.store.recipes.find(r => r.id === id) : null;

  recipeDialogTitle.textContent = existing ? `Рецепт: ${existing.name}` : "Новый рецепт";
  rec_id.value = existing?.id ?? "";
  rec_id.disabled = !!existing;
  rec_kind.value = existing?.kind ?? "ingredients";
  rec_name.value = existing?.name ?? "";
  rec_desc.value = existing?.desc ?? "";
  rec_power.value = String(existing?.power ?? 1);
  rec_base_dc.value = existing?.baseDc ?? "";
  rec_image_file.value = existing?.imageFile ?? "";
  rec_img_t1.value = existing?.imageByTier?.["1"] ?? "";
  rec_img_t2.value = existing?.imageByTier?.["2"] ?? "";
  rec_img_t3.value = existing?.imageByTier?.["3"] ?? "";
  rec_img_t4.value = existing?.imageByTier?.["4"] ?? "";
  updatePreview(rec_preview, rec_image_file.value);

  buildRecipeMatchUI(existing);
  rec_delete.style.display = existing ? "inline-block" : "none";
  recipeDialog.showModal();
}

rec_kind.onchange = () => buildRecipeMatchUI(null);
rec_image_file.oninput = () => updatePreview(rec_preview, rec_image_file.value);
rec_img_t1.oninput = () => updatePreview(rec_preview, rec_img_t1.value || rec_image_file.value);
rec_img_t2.oninput = () => updatePreview(rec_preview, rec_img_t2.value || rec_image_file.value);
rec_img_t3.oninput = () => updatePreview(rec_preview, rec_img_t3.value || rec_image_file.value);
rec_img_t4.oninput = () => updatePreview(rec_preview, rec_img_t4.value || rec_image_file.value);

function buildRecipeMatchUI(existing){
  const kind = rec_kind.value;
  rec_match_area.innerHTML = "";

  if (kind === "ingredients") {
    const selected = new Set(existing?.matchIngredients ?? []);
    const hint = document.createElement("div");
    hint.className = "small muted";
    hint.style.marginBottom = "6px";
    hint.textContent = "Выбери 2–3 ингредиента (точный матч по набору).";
    rec_match_area.appendChild(hint);

    for (const ing0 of state.store.ingredients.map(normalizeIngredient)) {
      const ing = ing0;
      const row = document.createElement("label");
      row.className = "card";
      row.style.cursor = "pointer";
      row.style.display = "flex";
      row.style.gap = "10px";
      row.style.alignItems = "center";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = selected.has(ing.id);
      cb.dataset.id = ing.id;

      row.appendChild(cb);

      const imgUrl = imgUrlOf(ing.imageFile);
      if (imgUrl) {
        const img = document.createElement("img");
        img.className = "img";
        img.alt = ing.name;
        img.src = imgUrl;
        row.appendChild(img);
      }

      const info = document.createElement("div");
      const costTxt = (ing.cost === null || ing.cost === undefined || ing.cost === "") ? "—" : `${ing.cost} зм`;
      info.innerHTML = `<strong>${escapeHtml(ing.name)}</strong>
        <div class="small muted">${RARITY[ing.rarity].name} • extract ${ing.extractPower} • ${costTxt}</div>`;
      row.appendChild(info);

      rec_match_area.appendChild(row);
    }
  } else {
    const selected = new Set(existing?.matchEffects ?? []);
    const hint = document.createElement("div");
    hint.className = "small muted";
    hint.style.marginBottom = "6px";
    hint.textContent = "Выбери эффекты: рецепт сработает, если эти тэги встречаются среди ингредиентов.";
    rec_match_area.appendChild(hint);

    const all = EFFECTS_ALL();
    const keys = Object.keys(all).sort((a,b) => (all[a].name||a).localeCompare(all[b].name||b, "ru"));

    const row = document.createElement("div");
    row.className = "row";
    for (const key of keys) {
      const lab = document.createElement("label");
      lab.className = "pill";
      lab.style.cursor = "pointer";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = selected.has(key);
      cb.dataset.key = key;
      cb.style.marginRight = "6px";
      lab.prepend(cb);
      lab.append(document.createTextNode(all[key].name || key));
      row.appendChild(lab);
    }
    rec_match_area.appendChild(row);
  }
}

rec_save.onclick = () => {
  const id = rec_id.value.trim();
  const name = rec_name.value.trim();
  if (!id || !/^[a-z0-9_\-]+$/i.test(id)) return alert("id рецепта обязателен (латиница/цифры/_/-).");
  if (!name) return alert("Название результата обязательно.");

  const kind = rec_kind.value;
  const power = Number(rec_power.value);
  const baseDcRaw = rec_base_dc.value.trim();
  const baseDc = baseDcRaw === "" ? null : Number(baseDcRaw);
  if (baseDc !== null && (!Number.isFinite(baseDc) || baseDc < 0)) return alert("baseDc должен быть числом >= 0 или пустым.");

  const imageFile = rec_image_file.value.trim() || null;
  const imageByTier = {
    "1": rec_img_t1.value.trim() || null,
    "2": rec_img_t2.value.trim() || null,
    "3": rec_img_t3.value.trim() || null,
    "4": rec_img_t4.value.trim() || null
  };
  const hasTierImages = Object.values(imageByTier).some(v => v);

  let matchIngredients = null;
  let matchEffects = null;

  if (kind === "ingredients") {
    matchIngredients = [...rec_match_area.querySelectorAll("input[type=checkbox]")]
      .filter(cb => cb.checked)
      .map(cb => cb.dataset.id);
    if (matchIngredients.length < 2 || matchIngredients.length > 3) return alert("Для точного рецепта выбери 2–3 ингредиента.");
  } else {
    matchEffects = [...rec_match_area.querySelectorAll("input[type=checkbox]")]
      .filter(cb => cb.checked)
      .map(cb => cb.dataset.key);
    if (matchEffects.length < 1) return alert("Для рецепта по эффектам выбери хотя бы 1 эффект.");
  }

  const obj = {
    id, kind, name,
    desc: rec_desc.value.trim(),
    power,
    baseDc,
    matchIngredients,
    matchEffects,
    imageFile,
    imageByTier: hasTierImages ? imageByTier : null
  };

  const exists = state.store.recipes.some(r => r.id === id);
  state.store.recipes = exists
    ? state.store.recipes.map(r => r.id === id ? obj : r)
    : [...state.store.recipes, obj];

  saveStore();
  renderAll();
  recipeDialog.close();
};

rec_delete.onclick = () => {
  const id = state.editingRecipeId;
  if (!id) return;
  if (!confirm("Удалить рецепт?")) return;
  state.store.recipes = state.store.recipes.filter(r => r.id !== id);
  saveStore();
  renderAll();
  recipeDialog.close();
};

/* ========= Effect editor ========= */
const effectDialog = document.getElementById("effectDialog");
const openEffectEditorBtn = document.getElementById("openEffectEditor");
const effectDialogTitle = document.getElementById("effectDialogTitle");
const eff_id = document.getElementById("eff_id");
const eff_name = document.getElementById("eff_name");
const eff_desc = document.getElementById("eff_desc");

const eff_power = document.getElementById("eff_power");
const eff_image_file = document.getElementById("eff_image_file");
const eff_img_t1 = document.getElementById("eff_img_t1");
const eff_img_t2 = document.getElementById("eff_img_t2");
const eff_img_t3 = document.getElementById("eff_img_t3");
const eff_img_t4 = document.getElementById("eff_img_t4");

const eff_save = document.getElementById("eff_save");
const eff_delete = document.getElementById("eff_delete");

let editingEffectId = null;

openEffectEditorBtn.onclick = () => openEffectEditor(null);

function openEffectEditor(id){
  editingEffectId = id;
  const custom = state.store.effects || {};
  const existing = id ? custom[id] : null;

  effectDialogTitle.textContent = existing ? `Эффект: ${existing.name}` : "Новый эффект";
  eff_id.value = id || "";
  eff_id.disabled = !!existing;
  eff_name.value = existing?.name || "";
  eff_desc.value = existing?.desc || "";
  eff_power.value = String(existing?.power ?? 1);

  eff_image_file.value = existing?.imageFile || "";
  eff_img_t1.value = existing?.imageByTier?.["1"] ?? "";
  eff_img_t2.value = existing?.imageByTier?.["2"] ?? "";
  eff_img_t3.value = existing?.imageByTier?.["3"] ?? "";
  eff_img_t4.value = existing?.imageByTier?.["4"] ?? "";
  eff_t1.value = existing?.tiers?.[0]?.desc ?? "";
  eff_t2.value = existing?.tiers?.[1]?.desc ?? "";
  eff_t3.value = existing?.tiers?.[2]?.desc ?? "";
  eff_t4.value = existing?.tiers?.[3]?.desc ?? "";
  eff_delete.style.display = existing ? "inline-block" : "none";
  effectDialog.showModal();
}

eff_save.onclick = () => {
  const id = eff_id.value.trim();
  const name = eff_name.value.trim();
  const desc = eff_desc.value.trim();
  const power = Number(eff_power.value);

  if (!id || !/^[a-z0-9_\-]+$/i.test(id)) return alert("id обязателен (латиница/цифры/_/-).");
  if (BASE_EFFECTS[id]) return alert("Этот id занят базовым эффектом. Выбери другой.");
  if (!name) return alert("Название обязательно.");
  if (!desc) return alert("Описание обязательно.");

  const tiersRaw = [
  eff_t1.value.trim(),
  eff_t2.value.trim(),
  eff_t3.value.trim(),
  eff_t4.value.trim()
  ];
  const tiers = tiersRaw.some(Boolean)
    ? tiersRaw.map(desc => ({ desc }))
    : null;

  state.store.effects ||= {};
  const imageFile = eff_image_file.value.trim() || null;
  const imageByTier = {
    "1": eff_img_t1.value.trim() || null,
    "2": eff_img_t2.value.trim() || null,
    "3": eff_img_t3.value.trim() || null,
    "4": eff_img_t4.value.trim() || null
  };
  const hasTierImages = Object.values(imageByTier).some(v => v);
  state.store.effects[id] = { name, power: clampInt(power,1,3), desc,  tiers,  imageFile, imageByTier: hasTierImages ? imageByTier : null };

  saveStore();
  renderAll();
  effectDialog.close();
};

eff_delete.onclick = () => {
  const id = editingEffectId;
  if (!id) return;
  if (!confirm("Удалить эффект? Он исчезнет из ингредиентов и рецептов.")) return;

  if (!state.store.effects) return;
  delete state.store.effects[id];

  state.store.ingredients = state.store.ingredients.map(ing => ({
    ...ing,
    effects: (ing.effects || []).filter(e => e !== id)
  }));

  state.store.recipes = state.store.recipes.map(r => {
    if (r.kind === "effects" && Array.isArray(r.matchEffects)) {
      return { ...r, matchEffects: r.matchEffects.filter(e => e !== id) };
    }
    return r;
  });

  saveStore();
  renderAll();
  effectDialog.close();
};

/* ========= Rendering ========= */
function renderAll(){
  renderIngredients();
  renderRecipes();
  renderEffects();
  renderZone(document.getElementById("bagZone"), elBagItems, state.bag, "bag");
  renderZone(document.getElementById("retortZone"), elRetortItems, state.retort, "retort");
}

function renderIngredients(){
  const q = elSearch.value.trim().toLowerCase();
  const rf = elRarityFilter.value;
  const all = EFFECTS_ALL();
  const eff_t1 = document.getElementById("eff_t1");
  const eff_t2 = document.getElementById("eff_t2");
  const eff_t3 = document.getElementById("eff_t3");
  const eff_t4 = document.getElementById("eff_t4");


  const items = state.store.ingredients.map(normalizeIngredient).filter(i => {
    if (rf && i.rarity !== rf) return false;
    if (!q) return true;
    const effectsText = (i.effects || []).map(e => all[e]?.name ?? e).join(" ").toLowerCase();
    const descText = (i.desc || "").toLowerCase();
    return (
      (i.name || "").toLowerCase().includes(q) ||
      (i.id || "").toLowerCase().includes(q) ||
      effectsText.includes(q) ||
      descText.includes(q)
    );
  });

  elIngredients.innerHTML = "";
  for (const ing of items) {
    const card = document.createElement("div");
    card.className = "card";
    card.draggable = true;
    card.dataset.id = ing.id;
    card.ondragstart = (ev) => ev.dataTransfer.setData("text/plain", ing.id);

    const top = document.createElement("div");
    top.className = "top";

    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.gap = "10px";
    left.style.alignItems = "center";

    const url = imgUrlOf(ing.imageFile);
    if (url) {
      const img = document.createElement("img");
      img.className = "img";
      img.alt = ing.name;
      img.src = url;
      left.appendChild(img);
    }

    const title = document.createElement("div");
    const costTxt = (ing.cost === null || ing.cost === undefined || ing.cost === "") ? "—" : `${ing.cost} зм`;
    title.innerHTML = `<div><strong>${escapeHtml(ing.name)}</strong> <span class="small muted">(${escapeHtml(ing.id)})</span></div>
      <div class="small muted">${costTxt} • ${RARITY[ing.rarity]?.name ?? ing.rarity} • extract ${ing.extractPower}</div>`;
    left.appendChild(title);

    const right = document.createElement("div");
    right.innerHTML = `<div class="tag">${RARITY[ing.rarity]?.name ?? ing.rarity}</div>`;
    top.appendChild(left);
    top.appendChild(right);

    const desc = document.createElement("div");
    desc.className = "small muted";
    desc.style.marginTop = "8px";
    desc.textContent = ing.desc ? ing.desc : "";

    const pills = document.createElement("div");
    pills.className = "pillbar";
    for (const e of ing.effects || []) {
      const pill = document.createElement("div");
      pill.className = "pill";
      pill.textContent = all[e]?.name ?? e;
      pills.appendChild(pill);
    }

    const actions = document.createElement("div");
    actions.className = "row";
    actions.style.marginTop = "8px";

    const add = document.createElement("button");
    add.type = "button";
    add.textContent = "В мешочек";
    add.onclick = () => addToBag(ing.id);

    const quick = document.createElement("button");
    quick.type = "button";
    quick.textContent = "В реторту";
    quick.onclick = () => addToRetort(ing.id);

    const edit = document.createElement("button");
    edit.type = "button";
    edit.textContent = "Редактировать";
    edit.onclick = () => openIngredientEditor(ing.id);

    actions.appendChild(add);
    actions.appendChild(quick);
    actions.appendChild(edit);

    card.appendChild(top);
    if (ing.desc) card.appendChild(desc);
    card.appendChild(pills);
    card.appendChild(actions);
    elIngredients.appendChild(card);
  }
}

function renderRecipes(){
  elRecipes.innerHTML = "";
  const recipes = [...state.store.recipes].sort((a,b) => (a.kind === b.kind ? 0 : (a.kind === "ingredients" ? -1 : 1)));
  const all = EFFECTS_ALL();

  for (const r of recipes) {
    const card = document.createElement("div");
    card.className = "card";

    const top = document.createElement("div");
    top.className = "top";

    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.gap = "10px";
    left.style.alignItems = "center";

    const url = imgUrlOf(r.imageFile);
    if (url) {
      const img = document.createElement("img");
      img.className = "img";
      img.alt = r.name;
      img.src = url;
      left.appendChild(img);
    }

    const title = document.createElement("div");
    title.innerHTML = `<div><strong>${escapeHtml(r.name)}</strong> <span class="small muted">(${escapeHtml(r.id)})</span></div>
      <div class="small muted">${r.kind === "ingredients" ? "Точный рецепт по ингредиентам" : "Рецепт по эффектам"}</div>`;
    left.appendChild(title);

    const right = document.createElement("div");
    right.innerHTML = `<div class="tag">Сила: ${["малая","средняя","сильная"][clampInt(r.power ?? 1,0,2)]}</div>`;
    top.appendChild(left);
    top.appendChild(right);

    const cond = document.createElement("div");
    cond.className = "small muted";
    cond.style.marginTop = "8px";
    cond.innerHTML = r.kind === "ingredients"
      ? `<strong>Ингредиенты:</strong> ${(r.matchIngredients||[]).map(id => escapeHtml(ingredientName(id))).join(", ")}`
      : `<strong>Эффекты:</strong> ${(r.matchEffects||[]).map(e => escapeHtml(all[e]?.name ?? e)).join(", ")}`;

    const actions = document.createElement("div");
    actions.className = "row";
    actions.style.marginTop = "8px";

    const edit = document.createElement("button");
    edit.type = "button";
    edit.textContent = "Редактировать";
    edit.onclick = () => openRecipeEditor(r.id);

    const load = document.createElement("button");
    load.type = "button";
    load.textContent = "В реторту";
    load.onclick = () => {
      if (r.kind !== "ingredients") return alert("Этот рецепт не по ингредиентам. Он срабатывает по эффектам.");
      state.retort = [...(r.matchIngredients||[])].slice(0,3);
      saveLocal("retort", state.retort);
      renderAll();
      showResult(null);
    };

    actions.appendChild(edit);
    actions.appendChild(load);

    card.appendChild(top);
    card.appendChild(cond);
    card.appendChild(actions);
    elRecipes.appendChild(card);
  }
}

function renderEffects(){
  effectsList.innerHTML = "";
  const custom = state.store.effects || {};
  const keys = Object.keys(custom).sort((a,b) => (custom[a].name||a).localeCompare(custom[b].name||b, "ru"));

  if (keys.length === 0) {
    effectsList.innerHTML = `<div class="small muted">Кастомных эффектов пока нет.</div>`;
    return;
  }

  for (const id of keys) {
    const e = custom[id];
    const card = document.createElement("div");
    card.className = "card";
    card.innerHTML = `
      <div class="top">
        <div><strong>${escapeHtml(e.name || id)}</strong> <span class="small muted">(${escapeHtml(id)})</span></div>
        <div class="tag">Сила: ${(e.power ?? 1)}</div>
      </div>
      <div class="small muted" style="margin-top:8px">${escapeHtml(e.desc || "")}</div>
      <div class="row" style="margin-top:8px">
        <button type="button" data-edit="${escapeHtml(id)}">Редактировать</button>
      </div>
    `;
    card.querySelector("button[data-edit]").onclick = () => openEffectEditor(id);
    effectsList.appendChild(card);
  }
}

function renderZone(zoneEl, container, ids, zoneName){
  container.innerHTML = "";
  attachDropHandlers(zoneEl, zoneName);

  ids.forEach((id, idx) => {
    const ing = state.store.ingredients.find(x => x.id === id);
    if (!ing) return;

    const chip = document.createElement("span");
    chip.className = "item";

    const url = imgUrlOf(ing.imageFile);
    if (url) {
      const img = document.createElement("img");
      img.className = "img";
      img.src = url;
      img.alt = ing.name;
      chip.appendChild(img);
    }

    const text = document.createElement("span");
    text.textContent = ing.name;
    chip.appendChild(text);

    const mv = document.createElement("button");
    mv.textContent = (zoneName === "bag") ? "→" : "←";
    mv.title = (zoneName === "bag") ? "В реторту" : "В мешочек";
    mv.onclick = () => {
      if (zoneName === "bag") {
        if (state.retort.length >= 3) return;
        const [m] = state.bag.splice(idx, 1);
        if (state.retort.includes(m)) {
          state.bag.splice(idx, 0, m);
          toast("Нельзя добавлять один и тот же ингредиент дважды в одну варку.");
          return;
        }
        state.retort.push(m);
      } else {
        const [m] = state.retort.splice(idx, 1);
        state.bag.push(m);
      }
      saveLocal("bag", state.bag); saveLocal("retort", state.retort);
      renderAll();
    };

    const rm = document.createElement("button");
    rm.textContent = "×";
    rm.title = "Убрать";
    rm.onclick = () => {
      if (zoneName === "bag") state.bag.splice(idx, 1);
      if (zoneName === "retort") state.retort.splice(idx, 1);
      saveLocal("bag", state.bag); saveLocal("retort", state.retort);
      renderAll();
      if (zoneName === "retort") showResult(null);
    };

    chip.appendChild(mv);
    chip.appendChild(rm);
    container.appendChild(chip);
  });
}

function attachDropHandlers(zone, zoneName){
  zone.ondragover = (ev) => { ev.preventDefault(); zone.classList.add("dragover"); };
  zone.ondragleave = () => zone.classList.remove("dragover");
  zone.ondrop = (ev) => {
    ev.preventDefault();
    zone.classList.remove("dragover");
    const id = ev.dataTransfer.getData("text/plain");
    if (!id) return;
    if (!state.store.ingredients.some(i => i.id === id)) return;
    if (zoneName === "bag") addToBag(id);
    if (zoneName === "retort") addToRetort(id);
  };
}

/* ========= Actions ========= */
function addToBag(id){
  state.bag.push(id);
  saveLocal("bag", state.bag);
  renderAll();
}
function addToRetort(id){
  if (state.retort.includes(id)) {
    toast("Нельзя добавлять один и тот же ингредиент дважды в одну варку.");
    return;
  }
  if (state.retort.length >= 3) return;
  state.retort.push(id);
  saveLocal("retort", state.retort);
  renderAll();
  showResult(null);
}

/* ========= Brew logic (tiered effects for everyone) ========= */
function computeBrew(ingredients, { labTier, maxEffects, timeMode }){
  const all = EFFECTS_ALL();

  // helper: compute support per effect
  const support = new Map();
  for (const ing0 of ingredients.map(normalizeIngredient)) {
    const ing = ing0;
    for (const e of (ing.effects || [])) {
      support.set(e, (support.get(e) || 0) + ing.extractPower);
    }
  }

  // 1) exact recipe by ingredients
  const ids = ingredients.map(i => i.id).sort();
  const exact = state.store.recipes.find(r => r.kind === "ingredients" && sameSet(ids, (r.matchIngredients||[]).slice().sort()));
  if (exact) return finalizeBrewFromRecipe(exact, ingredients, { labTier, timeMode, support });

  // 2) recipe by effects
// IMPORTANT: matchEffects must be "active" (Skyrim): appear in 2+ selected ingredients.
const counts = new Map();
for (const ing of ingredients) {
  for (const e of (ing.effects || [])) counts.set(e, (counts.get(e) || 0) + 1);
}
const intersect = [...counts.entries()]
  .filter(([e,c]) => c >= 2)
  .map(([e,_]) => e);
const sharedSet = new Set(intersect);
const effCandidates = state.store.recipes
  .filter(r => r.kind === "effects")
  .filter(r => (r.matchEffects||[]).length > 0 && (r.matchEffects||[]).every(e => sharedSet.has(e)));
if (effCandidates.length) {
  // choose the most specific/highest priority recipe
  effCandidates.sort((a,b) => ((b.matchEffects||[]).length - (a.matchEffects||[]).length)
    || ((b.power||0) - (a.power||0))
    || (a.name||a.id).localeCompare((b.name||b.id), "ru"));
  return finalizeBrewFromRecipe(effCandidates[0], ingredients, { labTier, timeMode, support });
}

// 3) Skyrim-style: intersection of effects (>=2 ingredients share)
if (intersect.length === 0) {
    return { error: "Эффекты не пересекаются. Попробуй другой набор или создай рецепт." };
  }

  intersect.sort((a,b) => ((all[b]?.power||1) - (all[a]?.power||1)) || (all[a]?.name||a).localeCompare(all[b]?.name||b, "ru"));
  const chosen = intersect.slice(0, maxEffects);

  return finalizeBrewFromEffects(chosen, ingredients, { labTier, timeMode, support });
}

function finalizeBrewFromEffects(effectKeys, ingredients, { labTier, timeMode, support }){
  const all = EFFECTS_ALL();

  const perEffect = effectKeys.map(k => {
    const meta = all[k] || { name: k, power: 1, desc: "" };
    const s = support.get(k) || 0;
    const tier = tierFromSupport(s);
    const desc = tieredDesc(meta, tier);
    const dc = dcFor(meta, tier, ingredients, labTier);
    const rests = timeFor(meta, tier, labTier);
    return { key:k, name: meta.name || k, power: meta.power || 1, tier, support: s, desc, dc, rests };
  });

  const title = perEffect.map(e => `${e.name} (Tier ${tierRoman(e.tier)})`).join(" + ");
  const body = perEffect.map(e => `• <strong>${escapeHtml(e.name)}</strong> <span class="tag">Tier ${tierRoman(e.tier)}</span><br>${escapeHtml(e.desc)}`).join("<br><br>");

  const dc = Math.max(...perEffect.map(e => e.dc));
  const rests = Math.max(...perEffect.map(e => e.rests));

  const notes = `DC берём по самому сложному эффекту. Время = по самому долгому эффекту.`;

    const primary = perEffect[0];
  const meta0 = primary ? (EFFECTS_ALL()[primary.key] || {}) : {};
  return {
    kind: "improvised",
    title,
    primaryTier: Math.max(...perEffect.map(e=>e.tier)),
    imageFile: meta0.imageFile || null,
    imageByTier: meta0.imageByTier || null,
    htmlDesc: body,
    dc,
    time: formatTime(rests, timeMode),
    perEffect,
    notes
  };
}

function finalizeBrewFromRecipe(recipe, ingredients, { labTier, timeMode, support }){
  const all = EFFECTS_ALL();

  // Determine "signature effects" for tier scaling:
  // - if recipe is effects-based -> those effects
  // - if ingredients-based -> pick intersections among selected (up to 2) to show tiers
  let keys = [];
  if (recipe.kind === "effects") keys = (recipe.matchEffects || []).slice(0, 2);
  if (recipe.kind === "ingredients") {
    const counts = new Map();
    for (const ing of ingredients) for (const e of (ing.effects||[])) counts.set(e, (counts.get(e)||0)+1);
    keys = [...counts.entries()].filter(([e,c]) => c>=2).map(([e,_])=>e);
    keys.sort((a,b)=>((all[b]?.power||1)-(all[a]?.power||1))|| (all[a]?.name||a).localeCompare(all[b]?.name||b,"ru"));
    keys = keys.slice(0,2);
  }
  if (keys.length === 0) keys = (recipe.matchEffects || []).slice(0,1);

  const perEffect = keys.map(k => {
    const meta = all[k] || { name: k, power: 1, desc: "" };
    const s = support.get(k) || 0;
    const tier = tierFromSupport(s);
    const desc = tieredDesc(meta, tier);
    const dc = dcForRecipe(recipe, meta, tier, ingredients, labTier);
    const rests = timeFor(meta, tier, labTier);
    return { key:k, name: meta.name || k, power: meta.power || 1, tier, support: s, desc, dc, rests };
  });

  const dc = Math.max(...perEffect.map(e => e.dc));
  const rests = Math.max(...perEffect.map(e => e.rests));

  const tierLine = perEffect.length
    ? perEffect.map(e => `${e.name}: Tier ${tierRoman(e.tier)} (support ${e.support})`).join("; ")
    : "—";

  const html = `
    <div class="small muted"><strong>Рецепт:</strong> ${escapeHtml(recipe.id)} • ${escapeHtml(recipe.kind)}</div>
    <div style="margin-top:8px">${escapeHtml(recipe.desc || "").replaceAll("\n","<br>")}</div>
    <hr style="border:0;border-top:1px solid #2b2e3a;margin:12px 0">
    <div class="small muted"><strong>Грейды по экстракту:</strong> ${escapeHtml(tierLine)}</div>
    ${perEffect.length ? `<div style="margin-top:10px">${perEffect.map(e=>`• <strong>${escapeHtml(e.name)}</strong> <span class="tag">Tier ${tierRoman(e.tier)}</span><br>${escapeHtml(e.desc)}`).join("<br><br>")}</div>` : ""}
  `;

    const primaryTier = perEffect.length ? Math.max(...perEffect.map(e=>e.tier)) : 1;
  const primary = perEffect[0];
  const meta0 = primary ? (EFFECTS_ALL()[primary.key] || {}) : {};
  const chosenImageFile = (recipe.imageFile || null) || (meta0.imageFile || null);
  const chosenImageByTier = (recipe.imageByTier || null) || (meta0.imageByTier || null);
  return {
    kind: "recipe",
    title: recipe.name,
    primaryTier,
    imageFile: chosenImageFile,
    imageByTier: chosenImageByTier,
    htmlDesc: html,
    dc,
    time: formatTime(rests, timeMode),
    perEffect,
    notes: `DC учитывает силу рецепта и Tier эффектов.`
  };
}

/* ========= DC & time ========= */
function dcFor(effectMeta, tier, ingredients, labTier){
  const rarityDc = Math.max(...ingredients.map(i => (RARITY[i.rarity]?.dc ?? 0)));
  const pow = clampInt(effectMeta.power ?? 1, 1, 3);
  const base = 10 + rarityDc + (pow - 1);      // baseline
  const tierAdd = 2 * (tier - 1);              // scaling knob for all effects
  const labMod = (labTier === "t0" ? 2 : (labTier === "t1" ? 0 : -2));
  return clampInt(base + tierAdd + labMod, 5, 30);
}

function dcForRecipe(recipe, effectMeta, tier, ingredients, labTier){
  const powRecipe = clampInt(recipe.power ?? 1, 0, 2);
  const baseAuto = 10 + Math.max(...ingredients.map(i => (RARITY[i.rarity]?.dc ?? 0))) + (powRecipe * 2);
  const base = (recipe.baseDc === null || recipe.baseDc === undefined || recipe.baseDc === "") ? baseAuto : Number(recipe.baseDc);
  const tierAdd = 2 * (tier - 1);
  const labMod = (labTier === "t0" ? 2 : (labTier === "t1" ? 0 : -2));
  // recipe's own difficulty + effect scaling
  return clampInt(base + tierAdd + labMod, 5, 35);
}

function timeFor(effectMeta, tier, labTier){
  // time in long rests: 1,2,4,8 for Tier I-IV
  let rests = Math.pow(2, tier - 1);

  // lab modifies time
  if (labTier === "t0") rests = Math.max(1, rests + 1);
  if (labTier === "t2") rests = Math.max(1, Math.ceil(rests / 2)); // ядро ускоряет

  return rests;
}

function formatTime(rests, mode){
  if (mode === "days") {
    if (rests === 1) return "≈ 1 день";
    return `≈ ${rests} дней`;
  }
  if (rests === 1) return "1 долгий отдых";
  return `${rests} долгих отдыха`;
}

function tieredDesc(meta, tier){
  // if effect has tiers array -> pick it
  if (meta.tiers && Array.isArray(meta.tiers) && meta.tiers.length >= tier) {
    return meta.tiers[tier-1].desc || meta.desc || "";
  }
  // fallback for custom effects
  const base = meta.desc || "";
  return base ? (`Tier ${tierRoman(tier)}: ` + base) : `Tier ${tierRoman(tier)}: (описание не задано)`;
}

/* ========= Result rendering ========= */
function showResult(brew){
  if (!brew) {
    elResult.innerHTML = `<div class="muted">Добавь 2–3 ингредиента в реторту и нажми “Сварить”.</div>`;
    return;
  }
  if (brew.error) {
    elResult.innerHTML = `<div class="danger" style="border:1px solid #ff5b5b; border-radius:12px; padding:10px; background:#140b0b">
      <strong>Не получилось</strong><div class="small" style="margin-top:6px">${escapeHtml(brew.error)}</div>
    </div>`;
    return;
  }

    const chosenFile = resolveImageFile(brew.imageFile, brew.imageByTier, brew.primaryTier || 1);
  const img = chosenFile ? imgUrlOf(chosenFile) : null;

  elResult.innerHTML = `
    <div class="row" style="justify-content:space-between; align-items:flex-start; gap:12px">
      <div style="flex:1">
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
          <strong style="font-size:16px">${escapeHtml(brew.title)}</strong>
          <span class="tag">DC: ${brew.dc}</span>
          <span class="tag">Время: ${escapeHtml(brew.time)}</span>
          ${brew.primaryTier ? `<span class="tag">Tier ${tierRoman(brew.primaryTier)}</span>` : ``}
          <span class="tag">${brew.kind === "recipe" ? "Рецепт" : "Импровизация"}</span>
        </div>
        <div class="small muted" style="margin-top:10px">${brew.htmlDesc || ""}</div>
        <div class="small muted" style="margin-top:10px">${escapeHtml(brew.notes || "")}</div>
      </div>
      ${img ? `<img class="imgBig" alt="result" src="${img}">` : ``}
    </div>
    <hr style="border:0;border-top:1px solid #2b2e3a;margin:12px 0">
    <div class="small muted">
      Проверка: <strong>Интеллект (Алхимические принадлежности)</strong> или <strong>Мудрость (Медицина)</strong>.
      На провале можно давать “ослабленный” Tier (−1), побочку или потерю части реагентов.
    </div>
  `;
}

/* ========= Utils ========= */
function imgUrlOf(file){
  if (!file) return null;
  const f = String(file).trim();
  if (!f) return null;
  return IMG_BASE + f;
}

function resolveImageFile(baseFile, byTier, tier){
  if (byTier && typeof byTier === "object"){
    const key = String(tier || 1);
    const candidate = byTier[key];
    if (candidate) return candidate;
  }
  return baseFile || null;
}
function updatePreview(imgEl, file){
  const url = imgUrlOf(file);
  if (!url) { imgEl.style.display = "none"; imgEl.removeAttribute("src"); return; }
  imgEl.src = url;
  imgEl.style.display = "block";
}
function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}
function ingredientName(id){
  return (state.store.ingredients.find(i => i.id === id)?.name) ?? id;
}
function sameSet(a,b){
  if (a.length !== b.length) return false;
  for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
  return true;
}
function clampInt(n, lo, hi){
  if (!Number.isFinite(n)) return lo;
  return Math.max(lo, Math.min(hi, Math.round(n)));
}
function toast(msg){
  alert(msg);
}

function downloadBlob(text, filename, mime){
  const blob = new Blob([text], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
